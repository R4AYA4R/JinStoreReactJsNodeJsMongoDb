import UserDto from "../dtos/userDto.js";
import ApiError from "../exceptions/ApiError.js";
import roleModel from "../models/roleModel.js";
import userModel from "../models/userModel.js";

import bcrypt from 'bcrypt'; // импортируем bcrypt для хеширования пароля(в данном случае импортируем вручную,иначе автоматически не импортируется)
import tokenService from "./tokenService.js";

// создаем класс UserService для сервиса пользователей(их удаление,добавление и тд)
class UserService {

    // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функци типа errorMiddleware и там обрабатывать ошибку))

    // функция регистрации,принимает в параметрах email,userName, и password(которые мы будем получать в теле запроса)
    async registration(email, password, userName) {

        const candidate = await userModel.findOne({ email }); // ищем в базе данных пользователя с таким же email,как и параметр этой функции email с помощью функции findOne() у нашей UserModel,передаем в параметре объект и поле email(по этому полю будет осуществляться поиск) и помещаем результат функции findOne(то есть найденный объект(если он был найден с таким же значением в поле email,как и параметр этой функции email)) в переменную candidate

        // если candidate true(то есть переменная candidate есть и в ней есть какое-то не пустое(не null) значение),то есть такой пользователь с таким email уже есть в базе данных
        if (candidate) {

            throw ApiError.BadRequest(`User with email ${email} already exists`);  // вместо throw new Error указываем throw ApiError(наш класс для обработки ошибок),указываем у него функцию BadRequest,то есть показываем ошибку с сообщением

        }

        const hashPassword = await bcrypt.hash(password, 3); // хешируем пароль с помощью функции hash() у bcrypt,первым параметром передаем пароль,а вторым - соль,степень хеширования(чем больше - тем лучше захешируется,но не нужно слишком большое число,иначе будет долго хешироваться пароль)

        const userRole = await roleModel.findOne({ value: "USER" }); // получаем роль(объект роли) из базы данных со значением USER и помещаем ее в переменную userRole

        const user = await userModel.create({ email, password: hashPassword, userName, role: userRole.value }); // создаем объект с полями email и password в базе данных и помещаем этот объект в переменную user,в поле password помещаем значение из переменной hashPassword,то есть уже захешированный пароль,и указываем в объекте еще поле activationLink(в данном случае не делаем активацию аккаунта по почте,поэтому не указываем здесь поле activationLink),в поле role указываем наш userRole.value(значение роли,которую мы получили из базы данных выше),так как мы получили объект из базы данных,а нам надо из него достать само значение

        const userDto = new UserDto(user); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект user,который мы создали в базе данных,в коде выше),в итоге переменная userDto(объект) будет обладать полями id,email,userName,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в токен) в токене

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken); // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }

    }

    async login(email, password) {

        const user = await userModel.findOne({ email }); // ищем в базе данных объект с полем email и значением как параметр email этой функции login,то есть проверяем,зарегестрирован ли пользователь вообще,и помещаем найденный(если он найден) объект в переменную user

        // если user false(или null),то есть такой пользователь не найден
        if (!user) {

            // используем throw для ошибки(когда используем throw(то мы указываем,что это типа исключение,которое нужно обрабатывать с помощью try catch в родительской функции),то ошибка идет к функции выше,к родительской функции,в которой эта функция была вызвана,и если у этой родительской функции не было обработки ошибок с помощью try catch,то будет ошибка,что не обработано исключение(то есть ошибка,но не та,которую мы хотели обработать),в данном случае,когда мы указываем throw ошибку,то она идет в родительскую функцию и там срабатывает блок catch,и в этом блоке catch мы описали,что передаем ошибку в функцию next(наш errorMiddleware),где она будет обработана,а при использовании return new Error(типа возвращаем ошибку),то это просто возвращается объект на основе класса Error и завершается функция,то есть код ниже этой строчки не выполнится,если будет ошибка с помощью return,и нужно обрабатывать где-то(в другой функции) возврат этой ошибки(то есть чтобы потом проверить,есть ли ошибка,то нужно будет ее в какой-нибудь родительской функции проверять,вернулась ли ошибка из дочерней функции и выводить ее в логи,а при throw ошибки,эта ошибка автоматически переходит в блок catch в родительской функции(нужно обязательно добавлять try catch в родительскую функцию,чтобы ловить ошибку с помощью throw)),так,например,в функции для эндпоинта есть функция callback next,и когда мы возвращаем ошибку с помощью return в функции для эндпоинта,то эта ошибка передается в функцию next и там уже обрабатывается(мы это сами прописывали,нужно для этого отдельно подключить свою функци типа errorMiddleware и там обрабатывать ошибку))
            throw ApiError.BadRequest('User with this email not found');  // бросаем ошибку с помощью нашего ApiError,указываем у него функцию BadRequest и передаем туда сообщение

        }

        const isPassEquals = await bcrypt.compare(password, user.password);  // сравниваем пароль,который отправил пользователь с захешированным паролем в базе данных,используем функцию compare() у bcrypt,передаем туда первым параметром пароль,который пользователь отправил(параметр этой функции login),а вторым параметром передаем пароль из базы данных(то есть пароль,который есть у объекта user(мы его нашли в переменной user по email))

        // если isPassEquals false(или null),то есть пароли не одинаковы
        if(!isPassEquals){

            throw ApiError.BadRequest('Wrong password'); // бросаем ошибку с помощью нашего ApiError,указываем у него функцию BadRequest и передаем туда сообщение

        }

        const userDto = new UserDto(user); // помещаем в переменную userDto объект,созданный на основе нашего класса UserDto и передаем в параметре конструктора модель(в данном случае объект user,который мы создали в базе данных,в коде выше),в итоге переменная userDto(объект) будет обладать полями id,email,userName,isActivated(в данном случае не делаем активацию аккаунта по почте,поэтому не будет тут у объекта пользователя поля isActivated),делаем это,чтобы убрать лишние(без пароля пользователя и тд) поля из объекта пользователя,который взяли из базы данных,которую можем передать как payload(данные,которые будут помещены в токен) в токене

        const tokens = tokenService.generateTokens({ ...userDto }); // помещаем в переменную tokens пару токенов,refresh и access токены,которые создались в нашей функции generateTokens(),передаем в параметре payload(данные,которые будут спрятаны в токен),в данном случае передаем в параметре объект,куда разворачиваем все поля объекта userDto(чтобы они отдельно развернулись в этот новый объект и добавились в токен)

        await tokenService.saveToken(userDto.id, tokens.refreshToken); // сохраняем refresh токен в базу данных,используя нашу функцию saveToken,передаем в параметрах userDto.id(id пользователя,который создали в базе данных) и refreshToken,который мы сгенерировали выше и поместили в объект tokens

        // возвращаем все поля объекта tokens(то есть access и refresh токены),и в поле user указываем значение userDto
        return {
            ...tokens,
            user: userDto
        }

    }

}

export default new UserService(); // экспортируем уже объект на основе нашего класса UserService