import productModel from "../models/productModel.js"; // указываем здесь вручную расширение файла .js,иначе выдает ошибку,что не может найти файл
 
class ProductController {

    // первым параметром эти функции принимают req(запрос),а вторым параметром res(ответ),третьим параметром передаем функцию next(следующий по цепочке middleware,в данном случае это наш errorMiddleware)
    async getProducts(req,res,next){

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        const { limit, skip } = req.query; // берем из параметров запроса поля limit и skip

        // оборачиваем в try catch для обработки ошибок
        try{

            const products = await productModel.find().limit(limit).skip(skip); // находим объекты всех блюд в базе данных mongodb с помощью метода find() у модели(схемы) productModel(модель товара), через точку указываем метод limit() и передаем в него значение лимита,в данном случае указываем,что лимит будет 2,то есть из базы данных придут максимум 2 объекта,через точку указываем метод skip() и передаем в него значение,сколько нужно пропустить объектов,прежде чем начать брать из базы данных mongodb, в данном случае указываем в методах limit и skip значения query параметров limit и skip,которые взяли из url(передали их с фронтенда) 

            console.log(products);

            return res.json(products); // возвращаем на клиент массив объектов товаров

        }catch(e){

            next(e); // вызываем функцию next()(параметр этой функции getProducts) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProducts,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    
    // создаем функцию для получения товаров для каталога
    async getProductsCatalog(req,res,next){

        const { limit, skip } = req.query; // берем из параметров запроса поля categoryId и tasteId,указываем здесь let,чтобы  можно было изменять значения этих параметров(переменных),в данном случае это надо для limit и page,также берем параметр sort(в нем будет название поля,по которому нужно сортировать,это мы передаем с фронтенда) и поле order(в нем будет значение,каким методом сортировать,например, 1(по возрастанию,от большего к меньшему), -1(по убыванию,от большего к меньшему) ),берем поле name,чтобы искать объекты блюд по этому полю name для поиска, берем поле inputLeftRangePrice(состояние цены левого инпута с типом range у ползунка для фильтра цены) и inputRightRangePrice(состояние цены правого инпута с типом range у ползунка для фильтра цены),чтобы фильтровать объекты блюд по цене

        // оборачиваем в try catch для обработки ошибок
        try{
            // пока просто находим все объекты товаров,потом будем делать их фильтрацию и тд
            const products = await productModel.find(); // находим объекты всех блюд в базе данных mongodb с помощью метода find() у модели(схемы) productModel(модель товара), через точку указываем метод limit() и передаем в него значение лимита,в данном случае указываем,что лимит будет 2,то есть из базы данных придут максимум 2 объекта,через точку указываем метод skip() и передаем в него значение,сколько нужно пропустить объектов,прежде чем начать брать из базы данных mongodb, в данном случае указываем в методах limit и skip значения query параметров limit и skip,которые взяли из url(передали их с фронтенда) 

            console.log(products);

            return res.json(products); // возвращаем на клиент массив объектов товаров

        }catch(e){

            next(e); // вызываем функцию next()(параметр этой функции getProducts) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProducts,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

}

export default new ProductController(); // экспортируем объект на основе класса ProductController,чтобы потом сразу можно было после импорта этого объекта из этого файла указывать через точку функции этого класса ProductController