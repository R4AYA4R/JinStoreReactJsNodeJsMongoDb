import { validationResult } from "express-validator";
import ApiError from "../exceptions/ApiError.js";
import userService from "../service/userService.js";

import * as path from 'path'; // импортируем все из модуля path для работы с файлами(в данном случае импортируем вручную и указываем *,то есть берем все из модуля path и указываем название этому всему как path)

import fs from 'fs'; // импортируем fs для работы с файлами
import productModel from "../models/productModel.js";
import adminFieldsModel from "../models/adminFieldsModel.js";
import commentModel from "../models/commentModel.js";

// создаем класс для UserController,где будем описывать функции для эндпоинтов
class UserController {

    // указываем фукнцию для эндпоинта регистрации,в параметре указываем req(запрос),res(ответ) и next(мидлвэир)
    async registration(req, res, next) {

        try {

            const errors = validationResult(req); // используем validationResult и передаем туда запрос(req),из него автоматически достанутся необходимые поля и провалидируются,и помещаем ошибки валидации в переменную errors

            // если errors.isEmpty() false,то есть массив ошибок не пустой
            if (!errors.isEmpty()) {

                return next(ApiError.BadRequest("Validation error during registration"), errors.array());// возвращаем функцию next(),используем здесь return,чтобы код ниже не читался,если была эта ошибка,вызываем функцию next()(параметр этой функции registration),то есть если была ошибка при валидации,то передаем ее в наш error-middleware,и в параметре next() указываем наш ApiError и у него указываем функцию BadRequest(она вернет объект,созданный на основе класса ApiError),куда передаем сообщение для ошибки и массив ошибок,полученных при валидации с помощью errors.array()

            }

            const { email, password, userName } = req.body; // вытаскиваем(деструктуризируем) из тела запроса поля email, password и userName 

            const userData = await userService.registration(email, password, userName); // так как функция registration из нашего userService асинхронная,то указываем await,вызываем нашу функцию registration из userService,передаем туда email, password и userName,в переменную userData помещаем токены и информацию о пользователе(это возвращает наша функция registration() из userService)

            res.cookie('refreshToken', userData.refreshToken, { maxAge: 30 * 24 * 60 * 60 * 1000, httpOnly: true }); // будем хранить refresh токен в cookie,вызываем функцю cookie() у res и передаем первым параметром название,по которому этот cookie будет храниться,а вторым параметром передаем сам cookie,(данные,которые будут храниться в cookie,то есть наш рефреш токен),третьим параметром передаем объект опций,указываем maxAge:30 дней умножаем на 24 часа * на 60 минут * 60 секунд * 1000 миллисекунд(это значит,что этот cookie будет жить 30 дней,указываем таким образом,потому что по-другому указать тут нельзя ),указываем httpOnly:true(чтобы этот cookie нельзя было изменять и получать внутри браузера),если используем https,то можно добавить флаг secure:true(это тоже самое,что httpOnly только для https)

            return res.json(userData);  // возвращаем на клиент объект userData с помощью json()

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async login(req, res, next) {

        try {

            const { email, password } = req.body; // вытаскиваем(деструктуризируем) из тела запроса поля email и password  

            const userData = await userService.login(email, password); // вызываем нашу функцию login из userService,передаем туда email и password,эта функция возвращает refreshToken и userDto(объект пользователя с полями id,email,userName,role) и помещаем эти данные в переменную userData

            res.cookie('refreshToken', userData.refreshToken, { maxAge: 30 * 24 * 60 * 60 * 1000, httpOnly: true }); // будем хранить refresh токен в cookie,вызываем функцю cookie() у res и передаем первым параметром название,по которому этот cookie будет храниться,а вторым параметром передаем сам cookie,(данные,которые будут храниться в cookie,то есть наш рефреш токен),третьим параметром передаем объект опций,указываем maxAge:30 дней умножаем на 24 часа * на 60 минут * 60 секунд * 1000 миллисекунд(это значит,что этот cookie будет жить 30 дней,указываем таким образом,потому что по-другому указать тут нельзя ),указываем httpOnly:true(чтобы этот cookie нельзя было изменять и получать внутри браузера),если используем https,то можно добавить флаг secure:true(это тоже самое,что httpOnly только для https)

            return res.json(userData);  // возвращаем на клиент объект userData с помощью json()

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async refresh(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const { refreshToken } = req.cookies; // достаем(деструктуризируем) refreshToken из cookies,то есть из запроса из поля cookies  

            const userData = await userService.refresh(refreshToken);// вызываем нашу функцию refresh из userService,передаем туда refreshToken,эта функция возвращает refreshToken,accessToken и userDto(объект пользователя с полями id,email,userName,role) и помещаем эти данные в переменную userData

            res.cookie('refreshToken', userData.refreshToken, { maxAge: 30 * 24 * 60 * 60 * 1000, httpOnly: true }); // будем хранить refresh токен в cookie,вызываем функцю cookie() у res и передаем первым параметром название,по которому этот cookie будет храниться,а вторым параметром передаем сам cookie,(данные,которые будут храниться в cookie,то есть наш рефреш токен),третьим параметром передаем объект опций,указываем maxAge:30 дней умножаем на 24 часа * на 60 минут * 60 секунд * 1000 миллисекунд(это значит,что этот cookie будет жить 30 дней,указываем таким образом,потому что по-другому указать тут нельзя ),указываем httpOnly:true(чтобы этот cookie нельзя было изменять и получать внутри браузера),если используем https,то можно добавить флаг secure:true(это тоже самое,что httpOnly только для https)

            return res.json(userData);  // возвращаем на клиент объект userData с помощью json()

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async logout(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const { refreshToken } = req.cookies; // достаем(деструктуризируем) refreshToken из cookies,то есть из запроса из поля cookies  

            const token = await userService.logout(refreshToken);// вызываем нашу функцию logout() и передаем туда refreshToken

            res.clearCookie('refreshToken'); // удаляем саму куку(cookie) с рефреш токеном,указываем функцию clearCookie() и передаем туда название cookie,которое хранит refreshToken

            return res.json(token); // возвращаем на клиент сам token(в данном случае это будет удаленный объект из базы данных у tokenModel,со значением refreshToken как и у refreshToken,который мы взяли из запроса из cookies(req.cookies), но в данном случае возвращается не сам удаленный объект токена из базы данных, а объект с полем deletedCount и значением 1,типа был удален объект)

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async changeAccInfo(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const errors = validationResult(req); // используем validationResult и передаем туда запрос(req),из него автоматически достанутся необходимые поля и провалидируются,и помещаем ошибки валидации в переменную errors

            const { userId, name, email } = req.body; // достаем(деструктуризируем) из тела запроса поля userId(id пользователя),name(новое имя пользователя) и email(новую почту)

            const newUserData = await userService.changeInfo(userId, name, email, errors);  // вызываем нашу функцию changeInfo в userService и туда передаем параметры и в переменную newUserData помещаем новый измененный объект пользователя в базе данных,передаем параметр errors в нашу функцию changeInfo,чтобы там обработать ошибку при валидации поля email

            return res.json(newUserData); // возвращаем на клиент объект newUserData с помощью json()

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async changeAccPass(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const { userId, currentPass, newPass } = req.body; // достаем(деструктуризируем) из тела запроса поля userId(id пользователя),currentPass(текущий пароль пользователя) и newPass(новый пароль пользователя)

            const newUserData = await userService.changePass(userId, currentPass, newPass);  // вызываем нашу функцию changePass в userService и туда передаем параметры и в переменную newUserData помещаем новый измененный объект пользователя в базе данных

            return res.json(newUserData); // возвращаем на клиент объект newUserData с помощью json()

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async uploadFile(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const image = req.files.image; // помещаем в переменную image сам файл (в данном случае файл картинки, но так можно и с любым файлом делать) под названием image(который мы указали в formData на фронтенде),у files у req(запроса)

            const folderPath = `${path.resolve()}\\checkStatic`; // помещаем в переменную folderPath путь на диске до папки checkStatic,которая возможно существует

            // если fs.existsSync(folderPath) false,то есть такого пути нет,который мы указали в переменной folderPath,то есть папки checkStatic нет,то ее создаем
            if (!fs.existsSync(folderPath)) {

                fs.mkdirSync(path.resolve('checkStatic')); // создаем папку с помощью mkdirSync(),указываем путь до этой папки с помощью path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsMongoDb) и добавляет к ней папку,которую мы передаем в параметре

            }

            const filePath = path.resolve('checkStatic', image.name); // помещаем в переменную filePath путь на диске,куда будем этот файл сохранять,используя resolve() у path(resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsMongoDb) и добавляет к ней папку,которую мы передаем в параметре(ее нужно сразу создать вручную)),и также передаем вторым параметром название файла,который нужно сохранить в этой папке

            const filePath2 = `${path.resolve()}\\checkStatic\\${image.name}`; // помещаем в переменную filePath2 путь до файла,который возможно существует,и ниже в коде проверяем,существует ли он(здесь path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsMongoDb) потом через слеши наша папка checkStatic(в которой мы храним все текущие скачанные файлы с фронтенда,когда пользователь только выбирает картинки,потом в эндпоинте(функции) создания нового товара будем сохранять эти файлы картинок в другую основную папку static,а из этой checkStatic будем удалять все файлы) и еще через слеши указываем название файла)

            const filePathStatic = `${path.resolve()}\\static\\${image.name}`; // помещаем в переменную filePathStatic путь до файла,который возможно существует в папке static,и ниже в коде проверяем,существует ли он(здесь path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsMongoDb) потом через слеши наша папка static(в которой мы храним все точные скачанные с фронтенда файлы картинок для товара)

            // если путь filePath2 существует(то есть уже есть такой файл в такой папке) или filePathStatic существует,то показываем ошибку,проверяем это с помощью fs.existsSync()
            if (fs.existsSync(filePath2) || fs.existsSync(filePathStatic)) {

                return next(ApiError.BadRequest('This file already exists')); // бросаем ошибку,возвращаем с помощью return нашу функцию next(это наш errorMiddleware) и передаем туда ошибку с помощью нашего ApiError и в BadRequest(наша функция для ошибки) передаем сообщение ошибки,не используем тут throw ApiError,так как это родительский компонент ошибки(то есть если и будет ошибка,то она будет только тут) и тут есть сразу функция next в параметрах этой функции uploadFile,указываем return,чтобы код ниже не работал,если будет ошибка,но можно тут указать и throw ApiError

            }

            image.mv(filePath); // перемещаем файл в папку по пути filePath

            // возвращаем на фронтенд объект с полями информации о файле
            return res.json({ name: image.name, path: filePath, file: image });

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async deleteCheckStatic(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const folderPath = `${path.resolve()}\\checkStatic`; // помещаем в переменную folderPath путь на диске до папки checkStatic,которая возможно существует

            // если fs.existsSync(folderPath) false,то есть такого пути нет,который мы указали в переменной folderPath,то есть папки checkStatic нет,то показываем ошибку
            if (!fs.existsSync(folderPath)) {

                return next(ApiError.BadRequest('No such file or directory'));

            }

            fs.rmSync(path.resolve('checkStatic'), { recursive: true }); // удаляем папку checkStatic,указываем до нее путь с помощью path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsMongoDb) и добавляет к ней папку,которую мы передаем в параметре,также указываем вторым параметром объект опций,указываем поле recursive:true,то есть папка будет удалена рекурсивно со всем содержимым

            // возвращаем на фронтенд объект с сообщением
            return res.json({ message: 'Successfully deleted' });

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async deleteImage(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const imageName = req.params.imageName; // получаем из параметров запроса название файла картинки,его мы указывали как динамический параметр у эндпоинта /deleteImage,поэтому ее мы можем взять и помещаем ее в переменную imageName,просто у delete запросов на сервер нету тела запроса и все параметры нужно передавать как query параметры запроса(то есть в url(ссылке) к эндпоинту)

            const imagePath = `${path.resolve()}\\checkStatic\\${imageName}`; // помещаем путь до файла,который хотим удалить в переменную imagePath(здесь path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsMongoDb) потом через слеши наша папка checkStatic в которой мы храним все скачанные файлы с фронтенда и еще через слеши указываем название файла)

            // если fs.existsSync(imagePath) false,то есть файл по такому пути,который находится в переменной imagePath не найден,то показываем ошибку и не удаляем такой файл,иначе может быть ошибка,когда хотим удалить файл,что такого файла и так нету
            if (!fs.existsSync(imagePath)) {

                return next(ApiError.BadRequest('No such file or directory to delete')); // бросаем ошибку,возвращаем с помощью return нашу функцию next(это наш errorMiddleware) и передаем туда ошибку с помощью нашего ApiError и в BadRequest(наша функция для ошибки) передаем сообщение ошибки,не используем тут throw ApiError,так как это родительский компонент ошибки(то есть если и будет ошибка,то она будет только тут) и тут есть сразу функция next в параметрах этой функции deleteImage,указываем return,чтобы код ниже не работал,если будет ошибка,но можно тут указать и throw ApiError

            }

            fs.unlinkSync(imagePath); // удаляем файл по такому пути,который находится в переменной imagePath с помощью fs.unlinkSync(),у модуля fs для работы с файлами есть методы обычные(типа unlink) и Sync(типа unlinkSync), методы с Sync блокируют главный поток node js и код ниже этой строки не будет выполнен,пока не будет выполнен метод с Sync

            return res.json({ message: 'Successfully deleted', deletedFilePath: imagePath }); // возвращаем на клиент объект с сообщением

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async deleteDescImage(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const imageName = req.params.imageName; // получаем из параметров запроса название файла картинки,его мы указывали как динамический параметр у эндпоинта /deleteImage,поэтому ее мы можем взять и помещаем ее в переменную imageName,просто у delete запросов на сервер нету тела запроса и все параметры нужно передавать как query параметры запроса(то есть в url(ссылке) к эндпоинту)

            const productId = req.params.productId; // получаем еще один параметр из параметров запроса,в данном случае productId(id товара,у которого надо удалить эту картинку),его мы указывали как динамический параметр у эндпоинта /deleteImage,поэтому ее мы можем взять и помещаем ее в переменную productId,просто у delete запросов на сервер нету тела запроса и все параметры нужно передавать как query параметры запроса(то есть в url(ссылке) к эндпоинту)

            const imagePath = `${path.resolve()}\\static\\${imageName}`; // помещаем путь до файла,который хотим удалить в переменную imagePath(здесь path.resolve() - берет текущую директорию(в данном случае директорию до \serverNodeJsMongoDb) потом через слеши наша папка static в которой мы храним все точные скачанные картинки для товара с фронтенда и еще через слеши указываем название файла)

            // если fs.existsSync(imagePath) false,то есть файл по такому пути,который находится в переменной imagePath не найден,то показываем ошибку и не удаляем такой файл,иначе может быть ошибка,когда хотим удалить файл,что такого файла и так нету
            if (!fs.existsSync(imagePath)) {

                return next(ApiError.BadRequest('No such file or directory to delete')); // бросаем ошибку,возвращаем с помощью return нашу функцию next(это наш errorMiddleware) и передаем туда ошибку с помощью нашего ApiError и в BadRequest(наша функция для ошибки) передаем сообщение ошибки,не используем тут throw ApiError,так как это родительский компонент ошибки(то есть если и будет ошибка,то она будет только тут) и тут есть сразу функция next в параметрах этой функции deleteImage,указываем return,чтобы код ниже не работал,если будет ошибка,но можно тут указать и throw ApiError

            }

            fs.unlinkSync(imagePath); // удаляем файл по такому пути,который находится в переменной imagePath с помощью fs.unlinkSync(),у модуля fs для работы с файлами есть методы обычные(типа unlink) и Sync(типа unlinkSync), методы с Sync блокируют главный поток node js и код ниже этой строки не будет выполнен,пока не будет выполнен метод с Sync

            const foundedProductCatalog = await productModel.findById(productId); // ищем объект товара в базе данных по id productId(id товара,который передали с фронтенда,чтобы у этого товара удалить картинку описания)

            foundedProductCatalog.descImages = foundedProductCatalog.descImages.filter(imgName => imgName !== imageName); // фильтруем массив descImages и оставляем в массиве только те названия картинок,которые не равны imageName(название картинки,которые мы передали с фронтенда,которую нужно удалить),таким образом удаляем из этого массива картинку imageName,которую и хотели удалить

            await foundedProductCatalog.save(); // сохраняем найденный объект товара в базе данных

            return res.json({ message: 'Successfully deleted', foundedProductCatalog }); // возвращаем на клиент объект с сообщением

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async getAdminFields(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const adminFields = await adminFieldsModel.findOne({});  // ищем объект у таблицы(сущности) adminFieldsModel в базе данных и помещаем его в переменную adminFields,передаем в findOne() пустой объект,чтобы найти первую попавшуюся запись у сущности adminFieldsModel(так как она там и так одна для всех полей,то ее так и находим),находим этот объект(он будет один со всеми нужными полями,так как мы его так создали в базе данных),в нем будут поля со значением текстов и разных полей на сайте,ищем и будем отображать потом на сайте,чтобы потом мог админ изменять их в базе данных

            return res.json(adminFields);

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async changePhoneNumber(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const phoneNumberObj = req.body; // достаем(деструктуризируем) из тела запроса весь объект запроса со всеми полями,которые мы передали с фронтенда(не используем здесь деструктуризацию типа деструктурировать из req.body {phoneNumberObj} в квадратных скобках,так как просто берем все тело запроса,то есть весь объект тела запроса,а не отдельные поля)

            console.log(phoneNumberObj);

            const foundedAdminFields = await adminFieldsModel.findOne({});  // ищем объект у таблицы(сущности) adminFieldsModel в базе данных и помещаем его в переменную foundedAdminFields,передаем в findOne() пустой объект,чтобы найти первую попавшуюся запись у сущности adminFieldsModel(так как она там и так одна для всех полей,то ее так и находим),находим этот объект(он будет один со всеми нужными полями,так как мы его так создали в базе данных),в нем будут поля со значением текстов и разных полей на сайте,ищем и будем отображать потом на сайте,чтобы потом мог админ изменять их в базе данных

            foundedAdminFields.phoneNumber = phoneNumberObj.newRealPhoneNumber; // изменяем поле phoneNumber у этого найденного объекта для админ полей(foundedAdminFields) на значение поля newRealPhoneNumber(новый реальный номер телефона без пробелов и тд)

            foundedAdminFields.visiblePhoneNumber = phoneNumberObj.newVisiblePhoneNumber; // изменяем поле phoneNumber у этого найденного объекта для админ полей(foundedAdminFields) на значение поля newVisiblePhoneNumber(новый визуальный номер телефона как он будет выглядеть на сайте)

            await foundedAdminFields.save(); // сохраняем обновленный объект полей для админа в базе данных

            return res.json(foundedAdminFields); // возвращаем на клиент  измененный объект админ полей


        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async addReplyForComment(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const comment = req.body; // достаем(деструктуризируем) из тела запроса весь объект запроса со всеми полями,которые мы передали с фронтенда(не используем здесь деструктуризацию типа деструктурировать из req.body {comment} в квадратных скобках,так как просто берем все тело запроса,то есть весь объект тела запроса,а не отдельные поля)

            const foundedComment = await commentModel.findById(comment._id); // находим объект комментария в базе данных по id,который равен _id у comment(объект тела запроса)

            foundedComment.adminReply = comment.adminReply; // изменяем поле adminReply у найденного объекта комментария на поле adminReply у comment(объект тела запроса,который передали с фронтенда)

            await foundedComment.save(); // сохраняем этот обновленный объект комментария в базе данных

            return res.json(foundedComment);  // возвращаем на клиент  измененный объект комментария


        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async deleteReplyFromAdmin(req, res, next) {

        // оборачиваем в блок try catch,чтобы отлавливать ошибки
        try {

            const commentId = req.params.commentId; // получаем из параметров запроса commentId (id объекта комментария,у которого хотим удалить ответ от админа),его мы указывали как динамический параметр у эндпоинта /deleteReplyFromAdmin,поэтому ее мы можем взять и помещаем ее в переменную commentId,просто у delete запросов на сервер нету тела запроса и все параметры нужно передавать как query параметры запроса(то есть в url(ссылке) к эндпоинту)

            const foundedComment = await commentModel.findById(commentId); // находим объект комментария в базе данных по id,который равен commentId (id у объекта комментария)

            foundedComment.adminReply = null; // изменяем поле adminReply у найденного объекта комментария на null,таким образом удаляем ответ от админа

            await foundedComment.save(); // сохраняем этот обновленный объект комментария в базе данных

            return res.json(foundedComment);  // возвращаем на клиент  измененный объект комментария


        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции registration) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции registration,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

}

export default new UserController(); // экспортируем уже объект на основе нашего класса UserController