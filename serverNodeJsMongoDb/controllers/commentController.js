
import { validationResult } from "express-validator";
import ApiError from "../exceptions/ApiError.js";
import userService from "../service/userService.js";
import commentModel from "../models/commentModel.js";

// создаем класс для CommentController,где будем описывать функции для эндпоинтов
class CommentController {

    // первым параметром эти функции принимают req(запрос),а вторым параметром res(ответ),третьим параметром передаем функцию next(следующий по цепочке middleware,в данном случае это наш errorMiddleware)
    async createComment(req, res, next) {

        // оборачиваем в try catch для обработки ошибок
        try {

            const comment = req.body; // достаем(деструктуризируем) из тела запроса весь объект запроса со всеми полями,которые мы передали с фронтенда(не используем здесь деструктуризацию типа деструктурировать из req.body {comment} в квадратных скобках,так как просто берем все тело запроса,то есть весь объект тела запроса,а не отдельные поля)

            const commentCreated = await commentModel.create({ ...comment }); // создаем объект комментария в базе данных,разворачивая весь объект comment(это весь объект тела запроса),вместо ...comment будут подставлены все поля с их значениями,которые есть в объекте тела запроса

            return res.json(commentCreated); // возвращаем созданный объект комментария на фронтенд

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции getProducts) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProducts,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }

    async getCommentsForProduct(req, res, next) {

        // оборачиваем в try catch для обработки ошибок
        try {

            let { productNameFor, page, limit } = req.query; // берем из url(строки) запроса параметр productNameFor,чтобы получить все комментарии для конкретного товара, указываем здесь let,чтобы  можно было изменять значения этих параметров(переменных),в данном случае это надо для limit и page

            page = page || 1; // указываем значение переменной page как параметр,который взяли из строки запроса,если он не указан,то делаем значение 1 

            limit = limit || 4; // указываем значение переменной limit как параметр,который взяли из строки запроса,если он не указан,то делаем значение 2

            let offset = page * limit - limit; // считаем отступ,допустим перешли на вторую страницу и первые 3 товара нужно пропустить(в данном случае это limit),поэтому умножаем page(текущую страницу) на limit и отнимаем лимит(чтобы правильно считались страницы,и показывалась последняя страница с товарами,если не отнять,то на последней странице товаров не будет,так как будет указано пропустить все объекты товаров из базы данных,прежде чем начать отправлять их),то есть offset считает,сколько нужно пропустить объектов до того,как отправлять объекты(например всего товаров 12, текущая страница 3,лимит 3, соответственно 3 * 3 - 3 будет 6,то есть 6 товаров пропустятся,на следующей странице(4) будет уже пропущено 4 * 3 - 3 равно 9(то есть 9 товаров пропущено будет), offset указывает пропустить указанное число строк(объектов в таблице в базе данных), прежде чем начать выдавать строки(объекты) )

            const allComments = await commentModel.find(); // находим все объекты комментариев с помощью find() у commentModel и помещаем их в переменную allComments,не указываем,что ищем по имени товара(productNameFor),так как потом будем фильтровать его сами на фронтенде по имени товара,чтобы отобразить количество комментариев для каждого товара,чтобы не было дополнительно много запросов на сервер

            const allCommentsForName = await commentModel.find({ productNameFor }); // находим все объекты комментариев с помощью find() у commentModel,у которых productNameFor равен параметру productNameFor,который мы взяли из url(строки) запроса,можно было указать и productNameFor:productNameFor,но так как названия параметра(который мы взяли из параметров запроса) и поля одинаковые,то можно указать просто productNameFor и помещаем их в переменную allComments,это ищем для пагинации

            const comments = await commentModel.find({ productNameFor }).sort({ _id: -1 }).limit(limit).skip(offset); // получаем все объекты комментариев,у которых productNameFor равен параметру productNameFor,который мы взяли из url(строки) запроса,можно было указать и productNameFor:productNameFor,но так как названия параметра(который мы взяли из параметров запроса) и поля одинаковые,то можно указать просто productNameFor, через точку указываем метод limit() и передаем в него значение лимита,в данном случае указываем,что лимит будет 4,то есть из базы данных придут максимум 4 объекта,через точку указываем метод skip() и передаем в него значение,сколько нужно пропустить объектов,прежде чем начать брать из базы данных mongodb,в данном случае указываем,что лимит будет 4,то есть из базы данных придут максимум 4 объекта,через точку указываем метод skip() и передаем в него значение,сколько нужно пропустить объектов,прежде чем начать брать из базы данных mongodb, в данном случае указываем значение переменной offset, указываем метод sort() для сортировки объектов,указываем в нем объект и поле _id со значением -1( -1(сортировка по убыванию),а 1(сортировка по возрастанию)),то есть будут сортироваться объекты по полю _id по убыванию,то есть самые последние добавленные объекты будут показываться первыми,что и нужно для комментариев

            return res.json({ allComments, allCommentsForName, comments }); // возвращаем эти комментарии на фронтенд

        } catch (e) {

            next(e); // вызываем функцию next()(параметр этой функции getProducts) и туда передаем ошибку,в этот next() попадает ошибка,и если ошибка будет от нашего класса ApiError(наш класс обработки ошибок,то есть когда мы будем вызывать функцию из нашего класса ApiError для обработки определенной ошибки,то эта функция будет возвращать объект с полями message и тд,и этот объект будет попадать в эту функцию next(в наш errorMiddleware) у этой нашей функции getProducts,и будет там обрабатываться),то она будет там обработана с конкретным сообщением,которое мы описывали,если эта ошибка будет не от нашего класса ApiError(мы обрабатывали какие-то конкретные ошибки,типа UnauthorizedError,ошибки при авторизации и тд),а какая-то другая,то она будет обработана как обычная ошибка(просто выведена в логи,мы это там прописали),вызывая эту функцию next(),мы попадаем в наш middleware error-middleware(который подключили в файле index.js)

        }

    }


}

export default new CommentController(); // экспортируем уже объект на основе нашего класса CommentController