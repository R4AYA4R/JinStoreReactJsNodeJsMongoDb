import ApiError from "../exceptions/ApiError.js"; // указываем здесь расширение файла .js вручную(потому что автоматически не указывается) при импорте нашего ApiError,иначе не находит файл и выдает ошибку
import tokenService from "../service/tokenService.js"; // указываем здесь расширение файла .js вручную(потому что автоматически не указывается) при импорте нашего tokenService,иначе не находит файл и выдает ошибку

// создаем и экспортируем функцию middleware,в параметрах принимает req(зарос),res(ответ),next(вызывает следующий в цепочке middleware),чтобы в данном случае получать доступ к изменению данных пользователя можно было только зарегестрированным пользователям,у которых есть access токен
export default function (req,res,next){

    // оборачиваем в try catch,чтобы отлавливать ошибки
    try{

        const authorizationHeader = req.headers.authorization; // помещаем в переменную authorizationHeader access токен из поля authorization у поля headers у запроса

        // если authorizationHeader false(или null),то есть этот header(заголовок) с токеном не указан
        if(!authorizationHeader){

            return next(ApiError.UnauthorizedError()); // возвращаем(используем return тут,чтобы после выполнения этой строчки кода,код ниже не работал,то есть когда ошибка,то остальная часть кода ниже не будет работать) функцию next(),которая по цепочке вызывает следующий middleware(в данном случае это будет наш errorMiddleware,который обработает эту ошибку и покажет ее),и в параметрах указываем нашу функцию UnauthorizedError() у ApiError,которая бросает ошибку и сообщение ошибки

        }

        const accessToken = authorizationHeader.split(' ')[1]; // разбиваем строку authorizationHeader по пробелу(эта строка состоит из типа токена и самого токена,типа Bearer(тип токена) lakdfa7889a7faknflajf(и типа сам токен)),и получаем массив из разбитых отдельных слов,и помещаем элемент этого нового массива по индексу 1(это и будет accessToken) в переменную accessToken

        // если accessToken false(или null),то есть accessToken нету
        if(!accessToken){

            return next(ApiError.UnauthorizedError()); // возвращаем(используем return тут,чтобы после выполнения этой строчки кода,код ниже не работал,то есть когда ошибка,то остальная часть кода ниже не будет работать) функцию next(),которая по цепочке вызывает следующий middleware(в данном случае это будет наш errorMiddleware,который обработает эту ошибку и покажет ее),и в параметрах указываем нашу функцию UnauthorizedError() у ApiError,которая бросает ошибку и сообщение ошибки

        }

        const userData = tokenService.validateAccessToken(accessToken); // используем нашу функцию validateAccessToken(),чтобы провалидировать(верифицировать) access токен,то есть в этой функции достаем из токена payload(данные,которые были помещеные в этот токен),если верификация прошла успешно,то эти данные помещаем в переменную userData

        // если userData false(или null),то есть если в userData ничего нет(если наша функция validateAccessToken вернула null при верификации)
        if(!userData){

            return next(ApiError.UnauthorizedError()); // возвращаем(используем return тут,чтобы после выполнения этой строчки кода,код ниже не работал,то есть когда ошибка,то остальная часть кода ниже не будет работать) функцию next(),которая по цепочке вызывает следующий middleware(в данном случае это будет наш errorMiddleware,который обработает эту ошибку и покажет ее),и в параметрах указываем нашу функцию UnauthorizedError() у ApiError,которая бросает ошибку и сообщение ошибки

        }

        req.user = userData; // в поле user у запроса помещаем userData(данные о пользователе,полученные из токена)

        next(); // вызываем функцию next(),тем самым передаем управление следующему middleware(то есть в данном случае передаем управление основной функции для эндпоинта,например,у эндпоинта /changeAccInfo будет передано управление функции changeAccInfo,то есть будет дальше выполняться функция changeAccInfo),но так как перед основной функцией для эндпоинта changeAccInfo мы указали еще middleware валидатор body(),то сначала управление будет передано этой функции,а потом уже функции changeAccInfo

    }catch(e){

        return next(ApiError.UnauthorizedError()); // возвращаем(используем return тут,чтобы после выполнения этой строчки кода,код ниже не работал,то есть в момент когда произошла ошибка,то остальная часть кода ниже не будет работать) функцию next(),которая по цепочке вызывает следующий middleware(в данном случае это будет наш errorMiddleware,который обработает эту ошибку и покажет ее),и в параметрах указываем нашу функцию UnauthorizedError() у ApiError,которая бросает ошибку и сообщение ошибки

    }

}